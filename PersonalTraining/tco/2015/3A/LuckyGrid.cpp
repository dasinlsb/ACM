/*
特判n==1
对于n!=11,n写成二元组(x,y)满足4*x+7*y==n要么有两个解要么没有解，而且有两个解的情况必定是abs(x1-x2)==abs(y1-y2)==1
可以考虑网络流做，对每一行每一列分别建点，源点向行连这一行还需要多少个4，每一列向汇点连这一列还需要多少个4，如果原图某个点(i,j)为空则行i向列j连边
但这样无法处理有两解的情况，因为这些边必须满流，而且更优的情况是流量再多1，简单的增加流量上限无法保证包租前一种限制
考虑构造费用流建图，源点向每一行再连一条流量为1，费用为1的边，表示另一个解，列同理，跑最小费用最大流
每个单位合法流量都对应放一个1，最大流保证了总和尽可能小
最小费用保证在流量相同的情况下，优先满足费用为0也就是必须要满流的边
跑完可以检验是否那些必须满流的边都已经满流，然后更新答案
*/
#include<bits/stdc++.h>
using namespace std;  
const int maxn=72;
int n,S,T,tot,ed,fir[maxn*2],G[maxn][maxn];
int row4[maxn],col4[maxn];
int limR[maxn],limC[maxn];
struct Edge{
  int v,w,c,nxt;
}e[(maxn*4+maxn*maxn)*2];
void adde(int x,int y,int w,int c){
  e[++ed].v=y;e[ed].w=w;e[ed].c=c;e[ed].nxt=fir[x];fir[x]=ed;
  e[++ed].v=x;e[ed].w=0;e[ed].c=-c;e[ed].nxt=fir[y];fir[y]=ed;
}
const int maxq=maxn*100;
int q[maxq],dis[maxn*2],inq[maxn*2],pre[maxn*2];
const int disinf=maxn*maxn*2;
int spfa(){
  for(int i=0;i<=tot;i++){
    dis[i]=disinf;
    inq[i]=0;
  }
  int h=maxq>>1,t=h-1;
  q[++t]=S;
  dis[S]=0;
  inq[S]=1;
  for(;h<=t;){
    int x=q[h++];
    for(int i=fir[x];i;i=e[i].nxt)if(e[i].w && dis[x]+e[i].c<dis[e[i].v]){
      dis[e[i].v]=dis[x]+e[i].c;
      pre[e[i].v]=i;
      if(!inq[e[i].v]){
        inq[e[i].v]=1;
        if(dis[e[i].v]<dis[q[h]])q[--h]=e[i].v;
        else q[++t]=e[i].v;
      }
    }
    inq[x]=0;
  }
  return dis[T]!=disinf;
}
void up(int&x,int y){if(x==-1 || y<x)x=y;}
int solve(){
  tot=2*n-1;
  S=++tot;
  T=++tot;
  ed=1;
  for(int i=0;i<=tot;i++){
    fir[i]=0;
  }
  int must=0;
  for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
      if(G[i][j]==0)adde(i,n+j,1,0);
    }
  }
  for(int i=0;i<n;i++){
    if(row4[i]>limR[i]+1)return -1;
    if(row4[i]<=limR[i]){
      must+=limR[i]-row4[i];
      adde(S,i,limR[i]-row4[i],0);
      adde(S,i,1,1);
    }
    if(col4[i]>limC[i]+1)return -1;
    if(col4[i]<=limC[i]){
      must+=limC[i]-col4[i];
      adde(n+i,T,limC[i]-col4[i],0);
      adde(n+i,T,1,1);
    }
  }
  int cost=0,flow=0;
  for(;spfa();){
    int w=2*n;
    for(int x=T;x!=S;x=e[pre[x]^1].v)w=min(w,e[pre[x]].w);
    for(int x=T;x!=S;x=e[pre[x]^1].v)e[pre[x]].w-=w,e[pre[x]^1].w+=w;
    flow+=w;
    cost+=dis[T]*w;
  }
  if(flow*2-cost!=must)return -1;
  int cnt4=flow;
  for(int i=0;i<n;i++)cnt4+=row4[i];
  return cnt4*4+(n*n-cnt4)*7;
}
int bit(int x){return __builtin_popcount(x);}
int test(int S1,int S2){
  if(bit(S1)>=2 && bit(S2)<9)return 0;
  if(11-bit(S1)>=2 && 11-bit(S2)<9)return 0;
  return 1;
}
int legal(int x){
  for(;x;x/=10)if(x%10!=4 && x%10!=7)return 0;
  return 1;
}
class LuckyGrid{
	public:
	int findMinimumSum(vector <string> grid){
		// $CARETPOSITION$
    memset(row4,0,sizeof row4);
    memset(col4,0,sizeof col4);
    n=grid.size();
    for(int i=0;i<n;i++){
      for(int j=0;j<n;j++){
        if(grid[i][j]=='.')G[i][j]=0;
        else G[i][j]=grid[i][j]-'0';
      }
    }
    if(n==1){
      return G[0][0]==7?7:4;
    }
    for(int i=0;i<n;i++){
      for(int j=0;j<n;j++){
        row4[i]+=G[i][j]==4;
        col4[j]+=G[i][j]==4;
      }
    }
    if(n==11){
      int ans=-1;
      for(int Srow=0;Srow<1<<n;Srow++){
        for(int Scol=0;Scol<1<<n;Scol++){
          if(!test(Srow,Scol) || !test(Scol,Srow))continue;
          for(int i=0;i<n;i++){
            limR[i]=(Srow>>i&1)?0:10;
            limC[i]=(Scol>>i&1)?0:10;
          }
          int res=solve();
          if(~res)up(ans,res);
        }
      }
      return ans;
    }
    int need4=-1;
    for(int i=0;i<=n;i++){
      if(legal(i*4+(n-i)*7)){
        need4=i;break;
      }
    }
    if(need4==-1)return -1;
    for(int i=0;i<n;i++){
      limR[i]=limC[i]=need4;
    }
    return solve();
	}
	
// BEGIN CUT HERE
	public:
	void run_test(int Case) { if ((Case == -1) || (Case == 0)) test_case_0(); if ((Case == -1) || (Case == 1)) test_case_1(); if ((Case == -1) || (Case == 2)) test_case_2(); if ((Case == -1) || (Case == 3)) test_case_3(); if ((Case == -1) || (Case == 4)) test_case_4(); if ((Case == -1) || (Case == 5)) test_case_5(); if ((Case == -1) || (Case == 6)) test_case_6(); if ((Case == -1) || (Case == 7)) test_case_7(); }
	private:
	template <typename T> string print_array(const vector<T> &V) { ostringstream os; os << "{ "; for (typename vector<T>::const_iterator iter = V.begin(); iter != V.end(); ++iter) os << '\"' << *iter << "\","; os << " }"; return os.str(); }
	void verify_case(int Case, const int &Expected, const int &Received) { cerr << "Test Case #" << Case << "..."; if (Expected == Received) cerr << "PASSED" << endl; else { cerr << "FAILED" << endl; cerr << "\tExpected: \"" << Expected << '\"' << endl; cerr << "\tReceived: \"" << Received << '\"' << endl; } }
	void test_case_0() { string Arr0[] = {"."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 4; verify_case(0, Arg1, findMinimumSum(Arg0)); }
	void test_case_1() { string Arr0[] = {"7"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 7; verify_case(1, Arg1, findMinimumSum(Arg0)); }
	void test_case_2() { string Arr0[] = {"........",
 "........",
 "........",
 "........",
 "........",
 "........",
 "........",
 "........"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 352; verify_case(2, Arg1, findMinimumSum(Arg0)); }
	void test_case_3() { string Arr0[] = {".4.",
 "7.7",
 "4.."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = -1; verify_case(3, Arg1, findMinimumSum(Arg0)); }
	void test_case_4() { string Arr0[] = {"774777..",
 "..4.....",
 "..7774..",
 "..7..7..",
 "..7..7..",
 "..7..74.",
 "..4..4..",
 "........"}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 355; verify_case(4, Arg1, findMinimumSum(Arg0)); }
	void test_case_5() { string Arr0[] = {
 ".44.....7..",
 ".44........",
 "...........",
 "...........",
 ".7.........",
 "...........",
 "...........",
 "...........",
 "...........",
 "...........",
 "..........."
 }; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 490; verify_case(5, Arg1, findMinimumSum(Arg0)); }
	void test_case_6() { string Arr0[] = {".4......7..",
 "...........",
 ".....7.....",
 "...........",
 ".7......7..",
 "...........",
 ".....4.....",
 "...........",
 "........4..",
 "...........",
 "..........."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 814; verify_case(6, Arg1, findMinimumSum(Arg0)); }
	void test_case_7() { string Arr0[] = {"..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 ".............477747774....77777.....477774........................",
 ".................4.......4.........4......4.......................",
 ".................4......4.........4........4......................",
 ".................7......7.........7........7......................",
 ".................4......4.........4........4......................",
 ".................4.......4.........4......4.......................",
 ".................7........77777.....777777........................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................", 
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 "..................................................................",
 ".................................................................."}; vector <string> Arg0(Arr0, Arr0 + (sizeof(Arr0) / sizeof(Arr0[0]))); int Arg1 = 29304; verify_case(7, Arg1, findMinimumSum(Arg0)); }

// END CUT HERE

};

// BEGIN CUT HERE  
int main(){
	LuckyGrid ___test;  
 	___test.run_test(-1);  
	return 0;  
}  
// END CUT HERE  
